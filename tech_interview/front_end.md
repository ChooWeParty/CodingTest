## HTML (HyperText Markup Language)
- 팀 버너스리에 의해 제안된 웹 페이지의 구조를 기술하기 위한 마크업 언어.
- 2008년 1월 HTML 5의 초안 작업이 W3C에 의해 발표 되었다.

## CSS (Cascading Style Sheet)
- HTML, XML 같은 마크업 언어로 작성된 문서의 스타일을 기술하기 위해 쓰이는 스타일시트 언어.
- 마크업 언어의 요소가 화면에 어떻게 렌더링되어야 하는지 기술함.
- CSS3은 표준화 과정에 있고, CSS2.1 버전이 권고 사항.

## Javscript
- 가벼운 인터프리터형 또는 JIT 컴파일형 프로그래밍 언어
- 객체 기반의 스크립트 프로그래밍 언어이다.
- 주로 웹 브라우저에서 사용되며, Node.js 같은 런타임 환경이 개발됨에 따라 서버 사이드에서도 사용되고 있다.
- `ECMAScript 5.1(ES5)` 버전은 모든 브라우저에서 지원하고 있으며, `ECMAScript 2015(ES6)`이 2015년 발표되어 많은 브라우저에서 지원을 하고 있으며, 2018년 10월 5일 `ECMAScript 2019`가 발표되었다.

## DOM (Document Object Model)
- HTML, XML 문서의 프로그래밍 인터페이스.
- 마크업 문서의 구조화된 표현을 제공하며, 프로그래밍 언어가 DOM 구조에 접근할 수 있는 방법을 제공하여 그들이 문서 구조, 스타일, 내용 등을 변경할 수 있게 돕는다.
- W3C DOM 표준은 대부분의 브라우저에서 DOM을 구현하는 기준이지만, 브라우저별로 DOM에서 지원하는 기능이 다를 수 있기 때문에, 브라우저 별로 작동이 다를 수 있다는 것을 인지해야한다.

## HTTP (HyperText Transfer Protocol)
- HTML 문서와 같은 리소스를 서버로 부터 가져올 수 있도록 해주는 프로토콜.
- 클라이언트-서버 모델 상에서 모든 데이터 교환의 기초.
- 클라이언트에서 전송하는 메시지를 `Request`라고 하며, 그에 대한 서버의 응답을 `Responce`라고 부름

### HTTP의 특징
- HTTP 메시지는 일반적으로 사람이 읽을 수 있게 만들어져 있어, 이해하기 쉽고 간단함.
- HTTP 헤더는 프로토콜을 확장하기 쉽게 만들었음.
- 각 요청은 독립적이며, 일반적으로는 HTTP는 상태를 가지지 않음
  - 쿠키의 사용은 상태가 있는 세션을 만들도록 도와줌
- HTTP는 일반적으로 TCP에 의존하고 있음.
  - TCP는 요청과 응답이 왕복해야하므로 느림.
  - HTTP/1.1에서 파이프라이닝 개념이 도입되어 개선됨
  - HTTP/2에서 단일 연결 상에서 메시지를 다중 전송 할 수 있음.

### HTTP의 진화
- **HTTP/0.9**
  - HTTP 헤더가 존재하지 않으며, 메소드는 GET만 가지고 있음.
- **HTTP/1.0**
  - HTTP 헤더가 추가되었음.
    - 헤더는 요청과 응답 모두에 도입되었음
    - 헤더에 상태 코드가 붙어 요청에 대한 성공과 실패를 알 수 있고, 그에 따라 브라우저가 동작할 수 있게 되었음
    - 헤더에 `Content-Type`이 추가되어 HTML 파일 이외에 다른 파일도 전송가능하게 되었음
- **HTTP/1.1**
  - 표준 프로토콜
  - 파이프라이닝 추가
    - 첫번째 요청에 대한 응답이 완전히 전송되지 않아도 두번째 전송을 보낼 수 있어, 커뮤니케이션 레이턴시를 낮춤
- **HTTP/2**
  - 텍스트 프로토콜이 아닌 이진 프로토콜로 변함
    - 인간이 읽을 수 있었던 이전 버전과 달리 인간이 읽을 수 없고, 수작업으로 만들 수 없음
  - 병렬 요청이 동일한 커넥션에서 이뤄질 수 있으며, 요청에 대한 순서가 없음
  - 전송된 데이터의 중복과 그런 데이터에서 발생하는 불필요한 오버헤드의 제거
    - 연속된 요청 사이의 유사한 헤더를 압축함.
  - 서버 푸시라는 새로운 개념이 등장
    - 클라이언트가 명시적으로 요청하지 않아도, 서버에서 필요하다고 판단되면 추가적일 리소스를 클라이언트에 푸시 할 수 있음.

### HTTP VS HTTPS
- HTTP는 인간이 읽을 수 있는 텍스트 프로토콜이기 때문에 중간자 공격같은 변조에 취약하다.
- HTTPS는 HTTP를 SSL로 감싸 서버와 클라이언트 간에 교환된 메시지 인증을 암호화 하고 보장하여 취약성을 종식시켰다.

### REST (Representational State Transfer)
- HTTP의 주요 저자인 로이 필딩에 의해 제안된 네트워크 아키텍처 원리의 모음.
- `네트워크 아키텍처 원리`란 리소스을 정의하고 리소스에 대한 주소를 지정하는 방법 전반을 일컫음.
- **REST 구성**
  - 자원: `URI`
  - 행위: `HTTP Method` (`GET`, `POST`, `PUT`, `DELETE`)
  - 표현
- **REST 디자인 가이드**
  1. URI는 정보의 자원을 표현해야한다.
  2. 자원에 대한 행위는 HTTP Method로 표현한다.

### HTTP 접근 제어 (CORS)
- 처음 전송된 리소스의 도메인과 다른 도메인에서 리소스가 요청될 경우를 **Cross-Origin HTTP 요청**이라 함.
- 브라우저들은 보안상의 이유로 스크립트에서 초기화되는 Cross Origin HTTP 요청을 제한함.
- CORS는 웹 서버에게 보안 Cross Domain 데이터 전송을 활성화 하는 접근 제어권을 부여함.

## SPA (Single Page Application)
- `단일 페이지 어플리케이션`
- 전통적인 **새로고침 방식의 웹**과는 달리 필요한 정적파일을 초기에 다운로드 받고, 이후 필요한 데이터만 서버로부터 *비동기*적으로 받아 트래픽의 총량을 줄이고, 네이티브 앱과 유사한 사용자 경험을 제공할 수 있는 어플리케이션 형태
- 모바일에서는 트래픽의 최소화, 속도 및 반응성, 사용성이 중요한 이유이기 때문에 주목 받고 있음.

### SPA의 단점과 해결책
- **초기 구동속도 문제**
  - SPA는 어플리케이션의 사용성을 위해 초기에 필요한 대부분의 리소스를 다운받는다.
  - **해결 방법**
    - 많은 자바스크립트 모듈 번들러에서는 `Lazy Loading` 혹은 `비동기 모듈 로딩`을 지원하고 있음.
      - **Lazy Loading**
        - 리소스를 Chunk 단위로 묶어 리소스에 대한 요청이 있을 때만 다운로드 받도록한다.
- **검색엔진 최적화(SEO) 문제**
  - SEO는 자바스크립트 기반의 클라이언트 렌더링 방식에서 항상 이슈였다.
  - 구글에서는 크롬을 통해 클라이언트 렌더링 방식도 검색 봇이 컨텐츠를 가져갈 수 있도록 개선하고 있지만, 많은 검색엔진이 그렇지 못하고 있다.
  - **해결 방법**
    - 제작 해야하는 웹 서비스가 SPA와 어울리는지 다시 한번 확인.
    - SPA를 위한 라이브러리, 프래임워크들이 SEO를 지원하기 위한 라이브러리를 지원하고 있으며, 이를 이용해 서버렌더링으로 전환 할 수 있다.
- **IE 8 이하 지원**
  - SPA는 Angular, React 같은 프래임워크 혹은 라이브러리의 도움없이는 만들기 힘듬
  - 최신의 자바스크립트 프래임워크들은 IE 8에 대한 지원을 하지 않는 추세
